/*
For a given list of digits 0 to 9, return a list with the same digits in the same order, but with all 0s paired. Pairing two 0s generates one 0 at the location of the first one.

Examples
input: [0, 1, 0, 2]
paired: ^-----^
    -> [0, 1,   2]
  kept: ^

input: [0, 1, 0, 0]
paired: ^-----^
    -> [0, 1,    0]
  kept: ^        ^

input: [1, 0, 7, 0, 1]
paired:    ^-----^
    -> [1, 0, 7,    1]
  kept:    ^

input: [0, 1, 7, 0, 2, 2, 0, 0, 1, 0]
paired: ^--------^        ^--^
    -> [0, 1, 7,    2, 2, 0,    1, 0]
  kept: ^                 ^        ^
Notes
Pairing happens from left to right. For each pairing, the second 0 will always be paired towards the first ( right to left )
0s generated by pairing can NOT be paired again
( void where not applicable: ) Don't modify the input array or you may fail to pass the tests
*/

// My solution:
const pairZeros = (arr) => {
  let zeroCount = 0;
  return arr
    .map((x) => {
      if (x === 0) {
        zeroCount++;
        if (zeroCount % 2 === 0) return (x = null);
      }
      return x;
    })
    .filter((x) => x !== null);
};

// My one-liner solution:
const pairZeros = (arr, zeroCount = 0) =>
  arr.reduce((acc, curr) => [...acc, curr === 0 ? [null, 0][++zeroCount % 2] : curr], []).filter((x) => x !== null);

// Top user solution:
function pairZeros(arr) {
  var seenZero = 0;
  return arr.filter(function (num) {
    return num != 0 || seenZero++ % 2 == 0;
  });
}

// My final solution:
const pairZeros = (arr, zeroCount = 0) => arr.filter((x) => x !== 0 || ++zeroCount % 2);

/* Takeaways:
1) Brain-fart! There was no reason to do a map before filter, as the filter aloen is enough.
*/
